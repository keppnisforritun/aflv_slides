\documentclass{beamer}
\usefonttheme[onlymath]{serif}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{gensymb}
\usepackage{parskip}
\usepackage{mathtools}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{color}
\usepackage{enumerate}
\usepackage{tikz}
\usetikzlibrary{calc}
\usetikzlibrary{positioning}
\usetikzlibrary{angles}
\usetikzlibrary{shapes}
\usetikzlibrary{arrows}
\usepackage{verbatim}
\usepackage{multicol}
\usepackage{array}
\usepackage{minted}
\parskip 0pt


\DeclareMathOperator{\lcm}{lcm}
\newcommand\floor[1]{\left\lfloor#1\right\rfloor}
\newcommand\ceil[1]{\left\lceil#1\right\rceil}
\newcommand\abs[1]{\left|#1\right|}
\newcommand\p[1]{\left(#1\right)}
\newcommand\sqp[1]{\left[#1\right]}
\newcommand\cp[1]{\left\{#1\right\}}
\newcommand\norm[1]{\left\lVert#1\right\rVert}
\renewcommand\Im{\operatorname{Im}}
\renewcommand\Re{\operatorname{Re}}

\usetheme{metropolis}
\definecolor{dark yellow}{rgb} {0.6,0.6,0.0}
\definecolor{dark green}{rgb} {0.0,0.6,0.0}

\graphicspath{{myndir/}}

\title{Square Root Decomposition}
\author{Arnar Bjarni Arnarson}
\institute{\href{http://ru.is/td}{School of Computer Science} \\[2pt] \href{http://ru.is}{Reykjav√≠k University}}
\titlegraphic{\hfill\includegraphics[height=0.6cm]{kattis}}

\begin{document}
\maketitle

\begin{frame}[plain]{Range queries}
    \vspace{30pt}
    \begin{itemize}
        \item<1-> We have an array $A$ of size $n$.
        \item<2-> Given $i,j$, we want to answer:
            \begin{itemize}
                \item<3-> $\mathrm{max}(A[i],A[i+1],\ldots,A[j-1],A[j])$
                \item<4-> $\mathrm{min}(A[i],A[i+1],\ldots,A[j-1],A[j])$
                \item<5-> $\mathrm{sum}(A[i],A[i+1],\ldots,A[j-1],A[j])$
            \end{itemize}
        \item<6-> We want to answer these queries efficiently, or in other words, without looking through all elements.
        \item<7-> Sometimes we also want to update elements.
    \end{itemize}
\end{frame}

\begin{frame}[plain]{Bucketing}
    \begin{itemize}
        \item<1-> Group values into buckets of size $k$ and store result of each bucket
        \item<2-> Updating is easy:
        \begin{itemize}
            \item<3-> change the array element
            \item<4-> recompute corresponding bucket
        \end{itemize}
        \item<5-> Time complexity: $O(k)$
        \item<6-> Again we want to query over a range
        \begin{itemize}
            \item<7-> When a bucket is contained in the range, use the stored sum for the bucket
            \item<8-> This (sometimes) allows us to ``jump'' over intervals of size $k$
            \item<9-> Only have to go inside at most two buckets (each end)
            \item<10-> Have to consider at most $n/k$ buckets and 2 buckets of size $k$
        \end{itemize}
        \item<11-> Time complexity: $O(n/k + k)$
    \end{itemize}
\end{frame}

\begin{frame}[plain]{Choosing number of buckets}
    \begin{itemize}
        \item<1-> Now we have a data structure that supports:
            \begin{itemize}
                \item<2-> Updating in $O(k)$
                \item Querying in $O(n/k + k)$
            \end{itemize}
        \item<3-> What $k$ to pick?
        \item<4-> Time complexity is minimized for $k=\sqrt{n}$:
            \begin{itemize}
                \item<5-> Updating in $O(\sqrt{n})$
                \item<6-> Querying in $O(n/\sqrt{n} + \sqrt{n}) = O(\sqrt{n})$
            \end{itemize}
        \item<7-> Also known as square root decomposition, and is a very
            powerful technique
    \end{itemize}
\end{frame}

\begin{frame}[plain]{Example problem: Supercomputer}
    \begin{itemize}
        \item https://open.kattis.com/problems/supercomputer
    \end{itemize}
\end{frame}

\begin{frame}[plain]{Offline and online}
    \begin{itemize}
        \item Usually we get all queries in a batch.
        \item This means we can compute the answers for all of them collectively. This is known as an offline algorithm.
        \item Conversely, an online algorithm is interactive and answers each query as it is received.
        \item The order in which we compute the answer may differ from the input order.
        \item After computing, we make sure to output them in the correct order.
        \item We will draw inspiration from the sliding window method.
    \end{itemize}
\end{frame}

\begin{frame}[plain]{Another sliding window method}
    \begin{itemize}
        \item Recall that when we move the right endpoint of a range, very little changes.
        \item Idea: sort the ranges by $(l, r)$.
        \item Then use the same methodology as sliding window.
        \item Define operations $\mathrm{add_R}, \mathrm{add_L}, \mathrm{del_R}, \mathrm{del_L}$ that shift the active range.
        \item Now we expand and contract as needed using these operations.
    \end{itemize}
\end{frame}

\begin{frame}[plain]{One slight problem}
    \begin{itemize}
        \item<1-> What is the worst case for this method?
        \item<2-> Consider ranges $(0, N-1), (1, 1), (2, N-1), (3, 3), (4, N-1), \dots$
        \item<3-> With $Q$ queries, each taking $N$ time, we get $\mathcal{O}(NQ)$.
        \item<3-> Bucketing by singular left endpoints is too rigid.
        \item<3-> We need more wiggle room.
    \end{itemize}
\end{frame}

\begin{frame}[plain]{Mo's algorithm}
    \begin{itemize}
        \item Lets pick a value $k$ which is the size of a bucket.
        \item Now sort by $(\left\lceil\frac{l}{k}\right\rceil, r)$.
        \item This puts ranges with similar values of $l$ close to each other.
        \item Then internally orders by $r$ in ascending order so we can build incrementally.
        \item Lets analyze the worst case here.
    \end{itemize}
\end{frame}

\begin{frame}[plain]{Analysis}
    \begin{itemize}
        \item<1-> If everything is in the same bucket, then we need one linear pass.
        \item<1-> Even distribution requires more linear passes for right endpoint.
        \item<2-> For the left endpoint, worst case is to wiggle maximally.
        \item<2-> We have $b = \frac{N}{k}$ buckets.
        \item<3-> Within each bucket, right endpoint will move by $N$ steps to the right and $N$ steps back when switching buckets.
        \item<4-> Even distribution gives $\frac{Q}{b}$ queries per bucket, each query moving left endpoint by $k$ steps.
        \item<5-> Time complexity is $\mathcal{O}\left(\frac{N}{k} \cdot (k \cdot \frac{Q}{b} + N)\right)$.
    \end{itemize}
\end{frame}

\begin{frame}[plain]{Choosing $k$}
    \begin{itemize}
        \item<1-> Optimal choice depends on $N$ and $Q$, but consider the common case of $Q \approx N$.
        \item<1-> Then all we need to do is find when $k^2 = N$.
        \item<1-> We saw this earlier, this is $k = \sqrt{N}$
        \item<2-> Then our total operations would be $2 \cdot N\sqrt{N}$ for the right endpoint and $\sqrt{N}^3$ for the left endpoint.
        \item<2-> Total is $3 \cdot N \sqrt{N}$.
        \item<2-> But this can be reduced to $2 \cdot N \sqrt{N}$ by reducing how much we move the right endpoint.
    \end{itemize}
\end{frame}
\end{document}
